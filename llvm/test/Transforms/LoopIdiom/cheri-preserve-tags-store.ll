; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --force-update
; We should be setting no_preserve_cheri_tags for loops that copy integers, and must_preserve_cheri_tags for capability copies.
; FIXME: this does not work with addrspace(200) pointers yet since we need SCEV.
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/-A200-P200-G200//g' %s | \
; RUN:    opt --passes='require<aa>,loop(loop-idiom,loop-deletion),simplifycfg' -aa-pipeline=basic-aa -S | \
; RUN:   FileCheck %s --check-prefixes=HYBRID
; RUN: opt --passes='require<aa>,loop(loop-idiom,loop-deletion),simplifycfg' -aa-pipeline=basic-aa -S | \
; RUN:   FileCheck %s --check-prefixes=PURECAP
target datalayout = "e-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-A200-P200-G200"

%struct.state = type { [25 x i32], i32 }
%struct.capstate = type { [25 x i32 addrspace(200)*], i32 }

@nocap = unnamed_addr addrspace(200) global [25 x i32] zeroinitializer, align 4
@cap = unnamed_addr addrspace(200) global [25 x i32 addrspace(200)*] zeroinitializer, align 4
@k = unnamed_addr addrspace(200) global i32 0, align 4

define void @get_state(%struct.state addrspace(200)* nocapture noalias %state) local_unnamed_addr addrspace(200) #0 {
; HYBRID-LABEL: @get_state(
; HYBRID-NEXT:  entry:
; HYBRID-NEXT:    [[STATE1:%.*]] = bitcast %struct.state* [[STATE:%.*]] to i8*
; HYBRID-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[STATE1]], i8* align 4 bitcast ([25 x i32]* @nocap to i8*), i64 100, i1 false) #[[ATTR1:[0-9]+]]
; HYBRID-NEXT:    ret void
;
; PURECAP-LABEL: @get_state(
; PURECAP-NEXT:  entry:
; PURECAP-NEXT:    br label [[FOR_BODY:%.*]]
; PURECAP:       for.body:
; PURECAP-NEXT:    [[I_08:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; PURECAP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [25 x i32], [25 x i32] addrspace(200)* @nocap, i64 0, i64 [[I_08]]
; PURECAP-NEXT:    [[TMP0:%.*]] = load i32, i32 addrspace(200)* [[ARRAYIDX]], align 4
; PURECAP-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [[STRUCT_STATE:%.*]], [[STRUCT_STATE]] addrspace(200)* [[STATE:%.*]], i64 0, i32 0, i64 [[I_08]]
; PURECAP-NEXT:    store i32 [[TMP0]], i32 addrspace(200)* [[ARRAYIDX2]], align 4
; PURECAP-NEXT:    [[INC]] = add nuw nsw i64 [[I_08]], 1
; PURECAP-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INC]], 25
; PURECAP-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; PURECAP:       for.end:
; PURECAP-NEXT:    ret void
;
entry:
  br label %for.body.preheader

for.body.preheader:                                   ; preds = %0
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.08 = phi i64 [ 0, %for.body.preheader ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds [25 x i32], [25 x i32] addrspace(200)* @nocap, i64 0, i64 %i.08
  %0 = load i32, i32 addrspace(200)* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds %struct.state, %struct.state addrspace(200)* %state, i64 0, i32 0, i64 %i.08
  store i32 %0, i32 addrspace(200)* %arrayidx2, align 4
  %inc = add nuw nsw i64 %i.08, 1
  %exitcond = icmp ne i64 %inc, 25
  br i1 %exitcond, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  ret void
}

define void @get_cap_state(%struct.capstate addrspace(200)* nocapture noalias %state) local_unnamed_addr addrspace(200) #0 {
; HYBRID-LABEL: @get_cap_state(
; HYBRID-NEXT:  entry:
; HYBRID-NEXT:    [[STATE1:%.*]] = bitcast %struct.capstate* [[STATE:%.*]] to i8*
; HYBRID-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 [[STATE1]], i8* align 16 bitcast ([25 x i32*]* @cap to i8*), i64 200, i1 false) #[[ATTR1]]
; HYBRID-NEXT:    ret void
;
; PURECAP-LABEL: @get_cap_state(
; PURECAP-NEXT:  entry:
; PURECAP-NEXT:    br label [[FOR_BODY:%.*]]
; PURECAP:       for.body:
; PURECAP-NEXT:    [[I_08:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; PURECAP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [25 x i32 addrspace(200)*], [25 x i32 addrspace(200)*] addrspace(200)* @cap, i64 0, i64 [[I_08]]
; PURECAP-NEXT:    [[TMP0:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)* addrspace(200)* [[ARRAYIDX]], align 16
; PURECAP-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [[STRUCT_CAPSTATE:%.*]], [[STRUCT_CAPSTATE]] addrspace(200)* [[STATE:%.*]], i64 0, i32 0, i64 [[I_08]]
; PURECAP-NEXT:    store i32 addrspace(200)* [[TMP0]], i32 addrspace(200)* addrspace(200)* [[ARRAYIDX2]], align 16
; PURECAP-NEXT:    [[INC]] = add nuw nsw i64 [[I_08]], 1
; PURECAP-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INC]], 25
; PURECAP-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; PURECAP:       for.end:
; PURECAP-NEXT:    ret void
;
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.08 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds [25 x i32 addrspace(200)*], [25 x i32 addrspace(200)*] addrspace(200)* @cap, i64 0, i64 %i.08
  %0 = load i32 addrspace(200)*, i32 addrspace(200)* addrspace(200)* %arrayidx, align 16
  %arrayidx2 = getelementptr inbounds %struct.capstate, %struct.capstate addrspace(200)* %state, i64 0, i32 0, i64 %i.08
  store i32 addrspace(200)* %0, i32 addrspace(200)* addrspace(200)* %arrayidx2, align 16
  %inc = add nuw nsw i64 %i.08, 1
  %exitcond = icmp ne i64 %inc, 25
  br i1 %exitcond, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  ret void
}

; UTC_ARGS: --disable
; HYBRID: attributes #[[ATTR1]] = { no_preserve_cheri_tags }
; HYBRID: attributes #[[ATTR2]] = { must_preserve_cheri_tags }
