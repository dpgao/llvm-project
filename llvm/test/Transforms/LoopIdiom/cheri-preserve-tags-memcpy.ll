; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --force-update
; Check that we retain the {must,no}_preserve_cheri_tags attribute when merging memcpy loops.
; FIXME: this does not work with addrspace(200) pointers yet since we need SCEV.
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/-A200-P200-G200//g' -e 's/.p200i8/.p0i8/g' %s | \
; RUN:    opt -passes='require<aa>,loop(loop-idiom,loop-deletion),simplifycfg' -aa-pipeline=basic-aa -S | \
; RUN:    FileCheck %s --check-prefixes=HYBRID,CHECK
; RUN: opt -passes='require<aa>,loop(loop-idiom,loop-deletion),simplifycfg' -aa-pipeline=basic-aa -S < %s | \
; RUN:    FileCheck %s --check-prefixes=PURECAP,CHECK
target datalayout = "e-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-A200-P200-G200"

; Created from the following reduced C testcase:
; struct sockaddr_in {
;   short sin_portsin_zero[8]
; };
; struct {
;   int nscount;
;   struct sockaddr_in nsaddr_list[]
; } __res_nsend_statp;
; int __res_nsend_ns;
; void __res_nsend() {
;   for (; __res_nsend_ns; __res_nsend_ns++)
;     __res_nsend_statp.nsaddr_list[__res_nsend_ns] =
;         __res_nsend_statp.nsaddr_list[__res_nsend_ns + 1];
; }

%struct.wombat = type { i16, %struct.foo, [8 x i8] }
%struct.foo = type { i32 }

define void @no_preserve(%struct.wombat addrspace(200)* noalias writeonly %dst, %struct.wombat addrspace(200)* noalias readonly %src, i32 %count) local_unnamed_addr #0 {
; HYBRID-LABEL: @no_preserve(
; HYBRID-NEXT:    [[DST1:%.*]] = bitcast %struct.wombat* [[DST:%.*]] to i8*
; HYBRID-NEXT:    [[TMP161:%.*]] = icmp sgt i32 [[COUNT:%.*]], 0
; HYBRID-NEXT:    br i1 [[TMP161]], label [[BB17_PREHEADER:%.*]], label [[BB30:%.*]]
; HYBRID:       bb17.preheader:
; HYBRID-NEXT:    [[SCEVGEP:%.*]] = getelementptr [[STRUCT_WOMBAT:%.*]], %struct.wombat* [[SRC:%.*]], i64 1
; HYBRID-NEXT:    [[SCEVGEP2:%.*]] = bitcast %struct.wombat* [[SCEVGEP]] to i8*
; HYBRID-NEXT:    [[TMP1:%.*]] = zext i32 [[COUNT]] to i64
; HYBRID-NEXT:    [[TMP2:%.*]] = shl nuw nsw i64 [[TMP1]], 4
; HYBRID-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 [[DST1]], i8* align 4 [[SCEVGEP2]], i64 [[TMP2]], i1 false) #[[ATTR2:[0-9]+]]
; HYBRID-NEXT:    br label [[BB30]]
; HYBRID:       bb30:
; HYBRID-NEXT:    ret void
;
; PURECAP-LABEL: @no_preserve(
; PURECAP-NEXT:    [[TMP161:%.*]] = icmp sgt i32 [[COUNT:%.*]], 0
; PURECAP-NEXT:    br i1 [[TMP161]], label [[BB17:%.*]], label [[BB30:%.*]]
; PURECAP:       bb17:
; PURECAP-NEXT:    [[TMP8_02:%.*]] = phi i32 [ [[TMP23:%.*]], [[BB17]] ], [ 0, [[TMP0:%.*]] ]
; PURECAP-NEXT:    [[TMP19:%.*]] = zext i32 [[TMP8_02]] to i64
; PURECAP-NEXT:    [[TMP20:%.*]] = getelementptr [[STRUCT_WOMBAT:%.*]], [[STRUCT_WOMBAT]] addrspace(200)* [[DST:%.*]], i64 [[TMP19]]
; PURECAP-NEXT:    [[TMP23]] = add nuw nsw i32 [[TMP8_02]], 1
; PURECAP-NEXT:    [[TMP24:%.*]] = zext i32 [[TMP23]] to i64
; PURECAP-NEXT:    [[TMP25:%.*]] = getelementptr [[STRUCT_WOMBAT]], [[STRUCT_WOMBAT]] addrspace(200)* [[SRC:%.*]], i64 [[TMP24]]
; PURECAP-NEXT:    [[TMP26:%.*]] = bitcast [[STRUCT_WOMBAT]] addrspace(200)* [[TMP20]] to i8 addrspace(200)*
; PURECAP-NEXT:    [[TMP27:%.*]] = bitcast [[STRUCT_WOMBAT]] addrspace(200)* [[TMP25]] to i8 addrspace(200)*
; PURECAP-NEXT:    tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noundef nonnull align 16 dereferenceable(16) [[TMP26]], i8 addrspace(200)* noundef nonnull align 4 dereferenceable(16) [[TMP27]], i64 16, i1 false) #[[ATTR2:[0-9]+]]
; PURECAP-NEXT:    [[TMP16:%.*]] = icmp slt i32 [[TMP23]], [[COUNT]]
; PURECAP-NEXT:    br i1 [[TMP16]], label [[BB17]], label [[BB30]]
; PURECAP:       bb30:
; PURECAP-NEXT:    ret void
;
  %tmp161 = icmp sgt i32 %count, 0
  br i1 %tmp161, label %bb17.preheader, label %bb30

bb17.preheader:                                   ; preds = %0
  br label %bb17

bb17:                                             ; preds = %bb17.preheader, %bb17
  %tmp8.02 = phi i32 [ %tmp23, %bb17 ], [ 0, %bb17.preheader ]
  %tmp19 = zext i32 %tmp8.02 to i64
  %tmp20 = getelementptr %struct.wombat, %struct.wombat addrspace(200)* %dst, i64 %tmp19
  %tmp23 = add nuw nsw i32 %tmp8.02, 1
  %tmp24 = zext i32 %tmp23 to i64
  %tmp25 = getelementptr %struct.wombat, %struct.wombat addrspace(200)* %src, i64 %tmp24
  %tmp26 = bitcast %struct.wombat addrspace(200)* %tmp20 to i8 addrspace(200)*
  %tmp27 = bitcast %struct.wombat addrspace(200)* %tmp25 to i8 addrspace(200)*
  tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noundef nonnull align 16 dereferenceable(16) %tmp26, i8 addrspace(200)* noundef nonnull align 4 dereferenceable(16) %tmp27, i64 16, i1 false) #1
  %tmp16 = icmp slt i32 %tmp23, %count
  br i1 %tmp16, label %bb17, label %bb30.loopexit

bb30.loopexit:                                    ; preds = %bb17
  br label %bb30

bb30:                                             ; preds = %bb30.loopexit, %0
  ret void
}

define void @must_preserve(%struct.wombat addrspace(200)* noalias writeonly %dst, %struct.wombat addrspace(200)* noalias readonly %src, i32 %count) local_unnamed_addr #0 {
; HYBRID-LABEL: @must_preserve(
; HYBRID-NEXT:    [[DST1:%.*]] = bitcast %struct.wombat* [[DST:%.*]] to i8*
; HYBRID-NEXT:    [[TMP161:%.*]] = icmp sgt i32 [[COUNT:%.*]], 0
; HYBRID-NEXT:    br i1 [[TMP161]], label [[BB17_PREHEADER:%.*]], label [[BB30:%.*]]
; HYBRID:       bb17.preheader:
; HYBRID-NEXT:    [[SCEVGEP:%.*]] = getelementptr [[STRUCT_WOMBAT:%.*]], %struct.wombat* [[SRC:%.*]], i64 1
; HYBRID-NEXT:    [[SCEVGEP2:%.*]] = bitcast %struct.wombat* [[SCEVGEP]] to i8*
; HYBRID-NEXT:    [[TMP1:%.*]] = zext i32 [[COUNT]] to i64
; HYBRID-NEXT:    [[TMP2:%.*]] = shl nuw nsw i64 [[TMP1]], 4
; HYBRID-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 [[DST1]], i8* align 4 [[SCEVGEP2]], i64 [[TMP2]], i1 false) #[[ATTR3:[0-9]+]]
; HYBRID-NEXT:    br label [[BB30]]
; HYBRID:       bb30:
; HYBRID-NEXT:    ret void
;
; PURECAP-LABEL: @must_preserve(
; PURECAP-NEXT:    [[TMP161:%.*]] = icmp sgt i32 [[COUNT:%.*]], 0
; PURECAP-NEXT:    br i1 [[TMP161]], label [[BB17:%.*]], label [[BB30:%.*]]
; PURECAP:       bb17:
; PURECAP-NEXT:    [[TMP8_02:%.*]] = phi i32 [ [[TMP23:%.*]], [[BB17]] ], [ 0, [[TMP0:%.*]] ]
; PURECAP-NEXT:    [[TMP19:%.*]] = zext i32 [[TMP8_02]] to i64
; PURECAP-NEXT:    [[TMP20:%.*]] = getelementptr [[STRUCT_WOMBAT:%.*]], [[STRUCT_WOMBAT]] addrspace(200)* [[DST:%.*]], i64 [[TMP19]]
; PURECAP-NEXT:    [[TMP23]] = add nuw nsw i32 [[TMP8_02]], 1
; PURECAP-NEXT:    [[TMP24:%.*]] = zext i32 [[TMP23]] to i64
; PURECAP-NEXT:    [[TMP25:%.*]] = getelementptr [[STRUCT_WOMBAT]], [[STRUCT_WOMBAT]] addrspace(200)* [[SRC:%.*]], i64 [[TMP24]]
; PURECAP-NEXT:    [[TMP26:%.*]] = bitcast [[STRUCT_WOMBAT]] addrspace(200)* [[TMP20]] to i8 addrspace(200)*
; PURECAP-NEXT:    [[TMP27:%.*]] = bitcast [[STRUCT_WOMBAT]] addrspace(200)* [[TMP25]] to i8 addrspace(200)*
; PURECAP-NEXT:    tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noundef nonnull align 16 dereferenceable(16) [[TMP26]], i8 addrspace(200)* noundef nonnull align 4 dereferenceable(16) [[TMP27]], i64 16, i1 false) #[[ATTR3:[0-9]+]]
; PURECAP-NEXT:    [[TMP16:%.*]] = icmp slt i32 [[TMP23]], [[COUNT]]
; PURECAP-NEXT:    br i1 [[TMP16]], label [[BB17]], label [[BB30]]
; PURECAP:       bb30:
; PURECAP-NEXT:    ret void
;
  %tmp161 = icmp sgt i32 %count, 0
  br i1 %tmp161, label %bb17.preheader, label %bb30

bb17.preheader:                                   ; preds = %0
  br label %bb17

bb17:                                             ; preds = %bb17.preheader, %bb17
  %tmp8.02 = phi i32 [ %tmp23, %bb17 ], [ 0, %bb17.preheader ]
  %tmp19 = zext i32 %tmp8.02 to i64
  %tmp20 = getelementptr %struct.wombat, %struct.wombat addrspace(200)* %dst, i64 %tmp19
  %tmp23 = add nuw nsw i32 %tmp8.02, 1
  %tmp24 = zext i32 %tmp23 to i64
  %tmp25 = getelementptr %struct.wombat, %struct.wombat addrspace(200)* %src, i64 %tmp24
  %tmp26 = bitcast %struct.wombat addrspace(200)* %tmp20 to i8 addrspace(200)*
  %tmp27 = bitcast %struct.wombat addrspace(200)* %tmp25 to i8 addrspace(200)*
  tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noundef nonnull align 16 dereferenceable(16) %tmp26, i8 addrspace(200)* noundef nonnull align 4 dereferenceable(16) %tmp27, i64 16, i1 false) #2
  %tmp16 = icmp slt i32 %tmp23, %count
  br i1 %tmp16, label %bb17, label %bb30.loopexit

bb30.loopexit:                                    ; preds = %bb17
  br label %bb30

bb30:                                             ; preds = %bb30.loopexit, %0
  ret void
}

declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noalias nocapture writeonly, i8 addrspace(200)* noalias nocapture readonly, i64, i1 immarg)

attributes #0 = { nofree nosync nounwind }
attributes #1 = { no_preserve_cheri_tags }
attributes #2 = { must_preserve_cheri_tags }

; UTC_ARGS: --disable
; CHECK: attributes #[[ATTR2]] = { no_preserve_cheri_tags }
; CHECK: attributes #[[ATTR3]] = { must_preserve_cheri_tags }
